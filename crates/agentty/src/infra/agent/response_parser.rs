use std::collections::HashMap;

use serde::Deserialize;

use crate::domain::session::SessionStats;

/// Parsed agent response including content text and usage statistics.
pub struct ParsedResponse {
    /// Final response text from the agent.
    pub content: String,
    /// Token usage statistics associated with `content`.
    pub stats: SessionStats,
}

/// Claude CLI JSON response shape.
#[derive(Deserialize)]
struct ClaudeResponse {
    result: Option<String>,
    usage: Option<ClaudeUsage>,
}

/// Token usage from a Claude CLI response.
#[derive(Deserialize)]
struct ClaudeUsage {
    input_tokens: Option<i64>,
    output_tokens: Option<i64>,
}

/// Gemini CLI JSON response shape.
#[derive(Deserialize)]
struct GeminiResponse {
    response: Option<String>,
    stats: Option<GeminiStats>,
}

/// Gemini CLI stream event shape.
#[derive(Deserialize)]
struct GeminiStreamEvent {
    #[serde(rename = "type")]
    event_type: Option<String>,
    stats: Option<GeminiStreamResultStats>,
}

/// Token usage from a Gemini stream `result` event.
#[derive(Deserialize)]
struct GeminiStreamResultStats {
    input_tokens: Option<i64>,
    output_tokens: Option<i64>,
}

/// Top-level `stats` object from Gemini CLI JSON output.
#[derive(Deserialize)]
struct GeminiStats {
    models: Option<HashMap<String, GeminiModelStats>>,
}

/// Per-model statistics from Gemini CLI.
#[derive(Deserialize)]
struct GeminiModelStats {
    tokens: Option<GeminiTokens>,
}

/// Token counts from a single Gemini model.
#[derive(Deserialize)]
struct GeminiTokens {
    /// Uncached prompt tokens (`max(0, prompt - cached)`).
    input: Option<i64>,
    /// Output/completion tokens generated by the model.
    candidates: Option<i64>,
}

/// Single NDJSON event emitted by Codex CLI (`--json`).
#[derive(Deserialize)]
struct CodexEvent {
    #[serde(rename = "type")]
    event_type: Option<String>,
    item: Option<CodexItem>,
    usage: Option<CodexUsage>,
}

/// Token usage from a Codex `turn.completed` event.
#[derive(Deserialize)]
struct CodexUsage {
    input_tokens: Option<i64>,
    output_tokens: Option<i64>,
}

/// Nested item payload from a Codex stream event.
#[derive(Deserialize)]
struct CodexItem {
    #[serde(rename = "type")]
    item_type: Option<String>,
    text: Option<String>,
}

/// Parses Claude output and falls back to raw output when parsing fails.
pub(super) fn parse_claude_response_with_fallback(stdout: &str, stderr: &str) -> ParsedResponse {
    parse_claude_response(stdout).unwrap_or_else(|| ParsedResponse {
        content: fallback_response(stdout, stderr),
        stats: SessionStats::default(),
    })
}

/// Parses Gemini output and falls back to raw output when parsing fails.
pub(super) fn parse_gemini_response_with_fallback(stdout: &str, stderr: &str) -> ParsedResponse {
    parse_gemini_response(stdout).unwrap_or_else(|| ParsedResponse {
        content: fallback_response(stdout, stderr),
        stats: SessionStats::default(),
    })
}

/// Parses Codex output and falls back to raw output when parsing fails.
pub(super) fn parse_codex_response_with_fallback(stdout: &str, stderr: &str) -> ParsedResponse {
    parse_codex_response(stdout).unwrap_or_else(|| ParsedResponse {
        content: fallback_response(stdout, stderr),
        stats: SessionStats::default(),
    })
}

fn parse_claude_response(stdout: &str) -> Option<ParsedResponse> {
    let trimmed_stdout = stdout.trim();
    if let Some(parsed_response) = parse_claude_response_payload(trimmed_stdout) {
        return Some(parsed_response);
    }

    for line in stdout.lines().rev() {
        let trimmed_line = line.trim();
        if trimmed_line.is_empty() {
            continue;
        }

        if let Some(parsed_response) = parse_claude_response_payload(trimmed_line) {
            return Some(parsed_response);
        }
    }

    None
}

/// Parses one Claude stream line into display text and content/progress type.
pub(super) fn parse_claude_stream_output_line(stdout_line: &str) -> Option<(String, bool)> {
    let trimmed_line = stdout_line.trim();
    if trimmed_line.is_empty() {
        return None;
    }

    if let Some(content) = extract_claude_stream_result(trimmed_line) {
        return Some((content, true));
    }

    let stream_event = serde_json::from_str::<serde_json::Value>(trimmed_line).ok()?;
    let progress_message = compact_progress_message_from_json(&stream_event)?;

    Some((progress_message, false))
}

fn parse_gemini_response(stdout: &str) -> Option<ParsedResponse> {
    let trimmed_stdout = stdout.trim();
    if let Some(parsed_response) = parse_gemini_response_payload(trimmed_stdout) {
        return Some(parsed_response);
    }

    let mut latest_legacy_response: Option<ParsedResponse> = None;
    let mut stream_response = String::new();
    let mut stream_stats: Option<SessionStats> = None;

    for line in stdout.lines() {
        let trimmed_line = line.trim();
        if trimmed_line.is_empty() {
            continue;
        }

        if let Some(parsed_response) = parse_gemini_response_payload(trimmed_line) {
            latest_legacy_response = Some(parsed_response);

            continue;
        }

        if let Some(stream_chunk) = extract_gemini_stream_response(trimmed_line) {
            stream_response.push_str(&stream_chunk);

            continue;
        }

        if let Some(parsed_stream_stats) = extract_gemini_stream_stats(trimmed_line) {
            stream_stats = Some(parsed_stream_stats);
        }
    }

    if let Some(parsed_response) = latest_legacy_response {
        return Some(parsed_response);
    }

    if stream_response.is_empty() && stream_stats.is_none() {
        return None;
    }

    let stats = stream_stats.unwrap_or_default();

    Some(ParsedResponse {
        content: stream_response,
        stats,
    })
}

/// Parses one Gemini stream line into display text and content/progress type.
pub(super) fn parse_gemini_stream_output_line(stdout_line: &str) -> Option<(String, bool)> {
    let trimmed_line = stdout_line.trim();
    if trimmed_line.is_empty() {
        return None;
    }

    let stream_event = serde_json::from_str::<serde_json::Value>(trimmed_line).ok()?;

    if let Some(content) = extract_gemini_stream_response_from_json(&stream_event) {
        return Some((content, true));
    }

    let progress_message = compact_progress_message_from_json(&stream_event)?;

    Some((progress_message, false))
}

/// Parses Codex NDJSON output into the final assistant message and usage.
///
/// Synthetic completion-status `agent_message` events are ignored so trailing
/// status lines do not replace the assistant-authored reply.
fn parse_codex_response(stdout: &str) -> Option<ParsedResponse> {
    let mut last_message: Option<String> = None;
    let mut total_input_tokens: u64 = 0;
    let mut total_output_tokens: u64 = 0;

    for line in stdout.lines() {
        let trimmed_line = line.trim();
        if trimmed_line.is_empty() {
            continue;
        }

        let Ok(event) = serde_json::from_str::<CodexEvent>(trimmed_line) else {
            continue;
        };

        if event.event_type.as_deref() == Some("turn.completed")
            && let Some(usage) = event.usage
        {
            total_input_tokens += usage.input_tokens.unwrap_or(0).cast_unsigned();
            total_output_tokens += usage.output_tokens.unwrap_or(0).cast_unsigned();
        }

        if event.event_type.as_deref() != Some("item.completed") {
            continue;
        }

        let Some(item) = event.item else {
            continue;
        };

        if item.item_type.as_deref() != Some("agent_message") {
            continue;
        }

        if let Some(text) = item.text {
            if is_codex_completion_status_message(&text) {
                continue;
            }

            last_message = Some(text);
        }
    }

    let stats = SessionStats {
        input_tokens: total_input_tokens,
        output_tokens: total_output_tokens,
    };

    last_message.map(|content| ParsedResponse { content, stats })
}

/// Parses one Codex stream line into display text and content/progress type.
pub(super) fn parse_codex_stream_output_line(stdout_line: &str) -> Option<(String, bool)> {
    let trimmed_line = stdout_line.trim();
    if trimmed_line.is_empty() {
        return None;
    }

    let event = serde_json::from_str::<CodexEvent>(trimmed_line).ok()?;
    if event.event_type.as_deref() == Some("item.started") {
        let item = event.item?;
        let item_type = item.item_type.as_deref()?;
        let progress_message = compact_codex_progress_message(item_type)?;

        return Some((progress_message, false));
    }

    if event.event_type.as_deref() != Some("item.completed") {
        return None;
    }

    let item = event.item?;
    if item.item_type.as_deref() != Some("agent_message") {
        return None;
    }

    let text = item.text?;
    if is_codex_completion_status_message(&text) {
        return None;
    }

    Some((text, true))
}

fn parse_claude_response_payload(stdout: &str) -> Option<ParsedResponse> {
    let response = serde_json::from_str::<ClaudeResponse>(stdout).ok()?;
    let content = response.result?;
    let stats = SessionStats {
        input_tokens: response
            .usage
            .as_ref()
            .and_then(|usage| usage.input_tokens)
            .unwrap_or(0)
            .cast_unsigned(),
        output_tokens: response
            .usage
            .as_ref()
            .and_then(|usage| usage.output_tokens)
            .unwrap_or(0)
            .cast_unsigned(),
    };

    Some(ParsedResponse { content, stats })
}

fn parse_gemini_response_payload(stdout: &str) -> Option<ParsedResponse> {
    let response = serde_json::from_str::<GeminiResponse>(stdout).ok()?;
    let content = response.response?;
    let stats = extract_gemini_stats(response.stats);

    Some(ParsedResponse { content, stats })
}

fn extract_claude_stream_result(stdout_line: &str) -> Option<String> {
    let response = serde_json::from_str::<ClaudeResponse>(stdout_line).ok()?;

    response.result
}

fn extract_gemini_stream_response(stdout_line: &str) -> Option<String> {
    let stream_event = serde_json::from_str::<serde_json::Value>(stdout_line).ok()?;

    extract_gemini_stream_response_from_json(&stream_event)
}

fn extract_gemini_stream_response_from_json(stream_event: &serde_json::Value) -> Option<String> {
    if let Some(legacy_response) = stream_event
        .get("response")
        .and_then(serde_json::Value::as_str)
    {
        return Some(legacy_response.to_string());
    }

    if stream_event.get("type").and_then(serde_json::Value::as_str) != Some("message") {
        return None;
    }

    if stream_event.get("role").and_then(serde_json::Value::as_str) != Some("assistant") {
        return None;
    }

    stream_event
        .get("content")
        .and_then(serde_json::Value::as_str)
        .map(ToString::to_string)
}

fn extract_gemini_stream_stats(stdout_line: &str) -> Option<SessionStats> {
    let stream_event = serde_json::from_str::<GeminiStreamEvent>(stdout_line).ok()?;
    if stream_event.event_type.as_deref() != Some("result") {
        return None;
    }

    let stats = stream_event
        .stats
        .map_or_else(SessionStats::default, |stats| SessionStats {
            input_tokens: stats.input_tokens.unwrap_or(0).cast_unsigned(),
            output_tokens: stats.output_tokens.unwrap_or(0).cast_unsigned(),
        });

    Some(stats)
}

fn compact_progress_message_from_json(stream_event: &serde_json::Value) -> Option<String> {
    let item_type = stream_event
        .get("item")
        .and_then(|item| item.get("type"))
        .and_then(serde_json::Value::as_str);
    if let Some(progress_message) = item_type.and_then(compact_progress_message_from_stream_label) {
        return Some(progress_message);
    }

    let tool_name = stream_event
        .get("tool_name")
        .and_then(serde_json::Value::as_str);
    if let Some(progress_message) = tool_name.and_then(compact_progress_message_from_stream_label) {
        return Some(progress_message);
    }

    let name = stream_event.get("name").and_then(serde_json::Value::as_str);
    if let Some(progress_message) = name.and_then(compact_progress_message_from_stream_label) {
        return Some(progress_message);
    }

    let tool_name = stream_event
        .get("tool")
        .and_then(|tool| tool.get("name"))
        .and_then(serde_json::Value::as_str);
    if let Some(progress_message) = tool_name.and_then(compact_progress_message_from_stream_label) {
        return Some(progress_message);
    }

    let event = stream_event
        .get("event")
        .and_then(serde_json::Value::as_str);
    if let Some(progress_message) = event.and_then(compact_progress_message_from_stream_label) {
        return Some(progress_message);
    }

    let subtype = stream_event
        .get("subtype")
        .and_then(serde_json::Value::as_str);
    if let Some(progress_message) = subtype.and_then(compact_progress_message_from_stream_label) {
        return Some(progress_message);
    }

    let event_type = stream_event.get("type").and_then(serde_json::Value::as_str);
    if let Some(progress_message) = event_type.and_then(compact_progress_message_from_stream_label)
    {
        return Some(progress_message);
    }

    None
}

fn compact_progress_message_from_stream_label(label: &str) -> Option<String> {
    let normalized_label = label.to_ascii_lowercase().replace('-', "_");
    if normalized_label.contains("search") {
        return Some("Searching the web".to_string());
    }

    if normalized_label.contains("reasoning")
        || normalized_label.contains("thinking")
        || normalized_label.contains("thought")
    {
        return Some("Thinking".to_string());
    }

    if normalized_label.contains("command")
        || normalized_label.contains("bash")
        || normalized_label.contains("terminal")
        || normalized_label.contains("shell")
        || normalized_label.contains("tool_use")
        || normalized_label.contains("tool_call")
        || normalized_label.contains("toolcall")
        || normalized_label.contains("execute")
    {
        return Some("Running a command".to_string());
    }

    None
}

/// Maps a Codex item type to a compact progress message for the UI.
///
/// Returns `None` for `agent_message` since it carries response content, not
/// progress.
pub(crate) fn compact_codex_progress_message(item_type: &str) -> Option<String> {
    match item_type {
        "agent_message" => None,
        "command_execution" => Some("Running a command".to_string()),
        "context_compaction" => Some("Compacting context".to_string()),
        "reasoning" => Some("Thinking".to_string()),
        "web_search" => Some("Searching the web".to_string()),
        other => Some(format!("Working: {}", other.replace('_', " "))),
    }
}

/// Returns whether a Codex `agent_message` is a synthetic completion status.
///
/// These short status lines are emitted for internal tool/reasoning steps and
/// should not be rendered as chat content.
pub(crate) fn is_codex_completion_status_message(message: &str) -> bool {
    let normalized_message = message.trim().trim_end_matches('.').to_ascii_lowercase();

    matches!(
        normalized_message.as_str(),
        "command completed"
            | "command execution completed"
            | "thinking completed"
            | "reasoning completed"
            | "search completed"
            | "web search completed"
    )
}

fn extract_gemini_stats(stats: Option<GeminiStats>) -> SessionStats {
    let Some(models) = stats.and_then(|stat| stat.models) else {
        return SessionStats::default();
    };

    let mut total_input_tokens: u64 = 0;
    let mut total_output_tokens: u64 = 0;

    for model_stats in models.values() {
        if let Some(tokens) = &model_stats.tokens {
            total_input_tokens += tokens.input.unwrap_or(0).cast_unsigned();
            total_output_tokens += tokens.candidates.unwrap_or(0).cast_unsigned();
        }
    }

    SessionStats {
        input_tokens: total_input_tokens,
        output_tokens: total_output_tokens,
    }
}

fn fallback_response(stdout: &str, stderr: &str) -> String {
    let trimmed_stdout = stdout.trim();
    if trimmed_stdout.is_empty() {
        return stderr.trim().to_string();
    }

    trimmed_stdout.to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_claude_parse_response_reads_result_payload() {
        // Arrange
        let stdout =
            r#"{"result":"Planned response","usage":{"input_tokens":11,"output_tokens":7}}"#;

        // Act
        let parsed = parse_claude_response_with_fallback(stdout, "");

        // Assert
        assert_eq!(parsed.content, "Planned response");
        assert_eq!(parsed.stats.input_tokens, 11);
        assert_eq!(parsed.stats.output_tokens, 7);
    }

    /// Ensures final NDJSON parsing keeps the real assistant reply when
    /// completion-status messages trail the stream.
    #[test]
    fn test_parse_response_codex_ignores_trailing_completion_status_message() {
        // Arrange
        let stdout = concat!(
            r#"{"type":"item.completed","item":{"type":"agent_message","text":"Planned final answer"}}"#,
            "\n",
            r#"{"type":"turn.completed","usage":{"input_tokens":21,"output_tokens":8}}"#,
            "\n",
            r#"{"type":"item.completed","item":{"type":"agent_message","text":"Command completed"}}"#,
        );

        // Act
        let parsed = parse_codex_response_with_fallback(stdout, "");

        // Assert
        assert_eq!(parsed.content, "Planned final answer");
        assert_eq!(parsed.stats.input_tokens, 21);
        assert_eq!(parsed.stats.output_tokens, 8);
    }

    #[test]
    fn test_parse_response_codex_ignores_completion_status_as_final_message() {
        // Arrange
        let stdout = concat!(
            r#"{"type":"item.completed","item":{"type":"agent_message","text":"Final answer"}}"#,
            "\n",
            r#"{"type":"item.completed","item":{"type":"agent_message","text":"Command completed"}}"#,
            "\n",
            r#"{"type":"turn.completed","usage":{"input_tokens":13,"output_tokens":9}}"#,
        );

        // Act
        let parsed = parse_codex_response_with_fallback(stdout, "");

        // Assert
        assert_eq!(parsed.content, "Final answer");
        assert_eq!(parsed.stats.input_tokens, 13);
        assert_eq!(parsed.stats.output_tokens, 9);
    }

    #[test]
    fn test_parse_stream_output_line_codex_ignores_completion_status_messages() {
        // Arrange
        let completion_status_lines = [
            r#"{"type":"item.completed","item":{"type":"agent_message","text":"Command completed"}}"#,
            r#"{"type":"item.completed","item":{"type":"agent_message","text":"Thinking completed"}}"#,
        ];

        // Act & Assert
        for completion_status_line in completion_status_lines {
            let parsed_line = parse_codex_stream_output_line(completion_status_line);

            assert_eq!(parsed_line, None);
        }
    }

    #[test]
    fn test_parse_stream_output_line_codex_keeps_assistant_message_content() {
        // Arrange
        let assistant_line =
            r#"{"type":"item.completed","item":{"type":"agent_message","text":"Final answer"}}"#;

        // Act
        let parsed_line = parse_codex_stream_output_line(assistant_line);

        // Assert
        assert_eq!(parsed_line, Some(("Final answer".to_string(), true)));
    }

    #[test]
    fn compact_codex_progress_message_returns_compacting_for_context_compaction() {
        // Arrange

        // Act
        let progress = compact_codex_progress_message("context_compaction");

        // Assert
        assert_eq!(progress, Some("Compacting context".to_string()));
    }
}
